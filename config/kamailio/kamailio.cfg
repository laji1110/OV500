#!KAMAILIO 
#!define WITH_DEBUG
#!define WITH_MYSQL
#!define WITH_AUTH
#!define WITH_USRLOCDB
#!define WITH_NAT
#!define WITH_ANTIFLOOD
#!define WITH_FREESWITCH
#!define WITH_CODE486408
#!define WITH_BLOCK3XX 
#!define WITH_IPAUTH
#!define WITH_EXEC
##!define WITH_HOMER
#
#!substdef "!MY_IP_ADDR!OV500LBIP!g"
#!substdef "!MY_UDP_PORT!5060!g"
#!substdef "!MY_UDP_ADDR!udp:MY_IP_ADDR:MY_UDP_PORT!g"

# Kamailio (OpenSER) SIP Server v4.3 - default configuration script
#     - web: http://www.kamailio.org
#     - git: http://sip-router.org
#
# Direct your questions about this file to: <sr-users@lists.sip-router.org>
#
# Refer to the Core CookBook at http://www.kamailio.org/dokuwiki/doku.php
# for an explanation of possible statements, functions and parameters.
#
# Several features can be enabled using '#!define WITH_FEATURE' directives:
#
# *** To run in debug mode: 
#     - define WITH_DEBUG
#
# *** To enable mysql: 
#     - define WITH_MYSQL
#
# *** To enable authentication execute:
#     - enable mysql
#     - define WITH_AUTH
#     - add users using 'kamctl'
#
# *** To enable IP authentication execute:
#     - enable mysql
#     - enable authentication
#     - define WITH_IPAUTH
#     - add IP addresses with group id '1' to 'address' table
#
# *** To enable persistent user location execute:
#     - enable mysql
#     - define WITH_USRLOCDB
#
#
# *** To enable nat traversal execute:
#     - define WITH_NAT
#     - install RTPProxy: http://www.rtpproxy.org
#     - start RTPProxy:
#        rtpproxy -l _your_public_ip_ -s udp:localhost:7722
#
# *** To enable PSTN gateway routing execute:
#     - define WITH_PSTN
#     - set the value of pstn.gw_ip
#     - check route[PSTN] for regexp routing condition
#
# *** To enable database aliases lookup execute:
#     - enable mysql
#     - define WITH_ALIASDB
#
# *** To enable multi-domain support execute:
#     - enable mysql
#     - define WITH_MULTIDOMAIN
#
# *** To enable TLS support execute:
#     - adjust CFGDIR/tls.cfg as needed
#     - define WITH_TLS
#
# *** To enable XMLRPC support execute:
#     - define WITH_XMLRPC
#     - adjust route[XMLRPC] for access policy
#
# *** To enable anti-flood detection execute:
#     - adjust pike and htable=>ipban settings as needed (default is
#       block if more than 16 requests in 2 seconds and ban for 300 seconds)
#     - define WITH_ANTIFLOOD
#
# *** To block 3XX redirect replies execute:
#     - define WITH_BLOCK3XX
#
#     - adjust the value of voicemail.srv_port
#
# *** To enhance accounting execute:
#     - enable mysql
#     - define WITH_ACCDB
#     - add following columns to database
#!ifdef ACCDB_COMMENT
  ALTER TABLE acc ADD COLUMN src_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN src_domain VARCHAR(128) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN src_ip varchar(64) NOT NULL default '';
  ALTER TABLE acc ADD COLUMN dst_ouser VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN dst_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN dst_domain VARCHAR(128) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN src_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN src_domain VARCHAR(128) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN src_ip varchar(64) NOT NULL default '';
  ALTER TABLE missed_calls ADD COLUMN dst_ouser VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN dst_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN dst_domain VARCHAR(128) NOT NULL DEFAULT '';
#!endif
 
####### Defined Values #########
 
# *** Value defines - IDs used later in config
#!ifdef WITH_MYSQL
# - database URL - used to connect to database server by modules such
#       as: auth_db, acc, usrloc, a.s.o.

#!ifndef DBURL 
#!define DBSIPLOG "mysql://ovswitch:ovswitch123@localhost/kamailio"
#!define DBKAMAILIO "mysql://ovswitch:ovswitch123@localhost/kamailio"
#!define DBSWITCH "mysql://ovswitch:ovswitch123@localhost/switch"
#!define HASHDB "mysql://ovswitch:ovswitch123@localhost/switch"
#!define DBCA "ca=>mysql://ovswitch:ovswitch123@localhost/switch"
#!define DBCDRCA "cdrca=>mysql://ovswitch:ovswitch123@localhost/switchcdr"
#!endif
#!endif
#!ifdef WITH_MULTIDOMAIN
# - the value for 'use_domain' parameters
#!define MULTIDOMAIN 1
#!else
#!define MULTIDOMAIN 0
#!endif
 
# - flags
#   FLT_ - per transaction (message) flags
#	FLB_ - per branch flags
#!define FLT_ACC 1
#!define FLT_ACCMISSED 2
#!define FLT_ACCFAILED 3
#!define FLT_NATS 5
#!define FLT_DLGINFO 10
#!define FLB_NATB 6
#!define FLB_NATSIPPING 7
 
####### Global Parameters #########
 
#!ifdef WITH_DEBUG
debug=2
log_stderror=no
#!else
debug=2
log_stderror=yes
#!endif
 
memdbg=5
memlog=5
 
log_facility=LOG_LOCAL0
 
fork=yes
children=4
 
/* uncomment the next line to disable TCP (default on) */
disable_tcp=no

/* uncomment the next line to disable the auto discovery of local aliases
   based on reverse DNS on IPs (default on) */
auto_aliases=no
/* add local domain aliases */
#alias="sip.mydomain.com"
 
/* uncomment and configure the following line if you want Kamailio to 
   bind on a specific interface/port/proto (default bind on all available) */
listen=MY_UDP_ADDR 
server_signature=no
server_header="OV500-2.0"
user_agent_header="User-Agent: OV500-2.0"
/* port to listen to
 * - can be specified more than once if needed to listen on many ports */
port=5060
 
#!ifdef WITH_TLS
enable_tls=yes
#!endif
 
# life time of TCP connection when there is no traffic
# - a bit higher than registration expires to cope with UA behind NAT
tcp_connection_lifetime=3605
 
####### Custom Parameters #########
 
# These parameters can be modified runtime via RPC interface
# - see the documentation of 'cfg_rpc' module.
#
# Format: group.id = value 'desc' description
# Access: $sel(cfg_get.group.id) or @cfg_get.group.id
#



####### Modules Section ########
 
# set paths to location of modules (to sources or installation folders)
#!ifdef WITH_SRCPATH
mpath="modules"
#!else
mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"
#!endif
 
#!ifdef WITH_MYSQL
loadmodule "db_mysql.so"
#!endif
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "textopsx.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "sdpops.so"
loadmodule "acc.so"
loadmodule "sqlops.so"
loadmodule "diversion.so"
loadmodule "dispatcher.so"
 
#!ifdef WITH_AUTH
loadmodule "auth.so"
loadmodule "auth_db.so"
#!ifdef WITH_IPAUTH
loadmodule "permissions.so"
#!endif
#!endif
 
#!ifdef WITH_ALIASDB
loadmodule "alias_db.so"
#!endif


#!ifdef WITH_MULTIDOMAIN
loadmodule "domain.so"
#!endif
loadmodule "dialog.so"

#!ifdef WITH_NAT
loadmodule "nathelper.so"
loadmodule "rtpproxy.so"
#!endif
 
#!ifdef WITH_TLS
loadmodule "tls.so"
#!endif
 
#!ifdef WITH_ANTIFLOOD
loadmodule "htable.so"
loadmodule "pike.so"
#!endif
 
#!ifdef WITH_XMLRPC
loadmodule "xmlrpc.so"
#!endif
 
#!ifdef WITH_DEBUG
loadmodule "debugger.so"
#!endif
 
#!ifdef WITH_FREESWITCH
loadmodule "uac.so"
loadmodule "path.so"
#!endif
 
#!ifdef WITH_HOMER
loadmodule "siptrace.so"
#!endif
# ----- Loading EXEC Module
#!ifdef WITH_EXEC
loadmodule "exec.so"
#!endif
loadmodule "cfgutils.so"
# ----------------- setting module-specific parameters ---------------
 
 
# ----- mi_fifo params -----
#modparam("mi_fifo", "fifo_name", "/var/run/kamailio/kamailio_fifo")
 
# ----- ctl params -----
#modparam("ctl", "binrpc", "unix:/var/run/kamailio/kamailio_ctl")
 
# ----- tm params -----
# auto-discard branches from previous serial forking leg
#modparam("tm", "failure_reply_mode", 3)
modparam("tm", "failure_reply_mode", 0)
# default retransmission timeout: 30sec
modparam("tm", "fr_timer", 30000)
# default invite retransmission timeout after 1xx: 120sec
modparam("tm", "fr_inv_timer", 120000)
modparam("tm", "remap_503_500", 0)
 
 
# ----- rr params -----
# add value to ;lr param to cope with most of the UAs
modparam("rr", "enable_full_lr", 1)
# do not append from tag to the RR (no need for this script)
#!ifdef WITH_FREESWITCH
modparam("rr", "append_fromtag", 1)
#!else
modparam("rr", "append_fromtag", 0)
#!endif
 
# ----- registrar params -----
modparam("registrar", "method_filtering", 1)
/* uncomment the next line to disable parallel forking via location */
modparam("registrar", "append_branches", 1)
/* uncomment the next line not to allow more than 10 contacts per AOR */
#modparam("registrar", "max_contacts", 10)
# max value for expires of registrations
modparam("registrar", "max_expires", 3600)
# set it to 1 to enable GRUU
modparam("registrar", "gruu_enabled", 0)
modparam("registrar", "received_avp", "$avp(RECEIVED)")
modparam("registrar", "case_sensitive", 1)
 
 
# ----- acc params -----
/* what special events should be accounted ? */
modparam("acc", "early_media", 0)
modparam("acc", "report_ack", 0)
modparam("acc", "report_cancels", 0)
/* by default ww do not adjust the direct of the sequential requests.
   if you enable this parameter, be sure the enable "append_fromtag"
   in "rr" module */
modparam("acc", "detect_direction", 0)
/* account triggers (flags) */
modparam("acc", "log_flag", FLT_ACC)
modparam("acc", "log_missed_flag", FLT_ACCMISSED)
modparam("acc", "log_extra", 
	"src_user=$fU;src_domain=$fd;src_ip=$si;"
	"dst_ouser=$tU;dst_user=$rU;dst_domain=$rd")
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)
/* enhanced DB accounting */
#!ifdef WITH_ACCDB
modparam("acc", "db_flag", FLT_ACC)
modparam("acc", "db_missed_flag", FLT_ACCMISSED)
modparam("acc", "db_url", DBKAMAILIO)
modparam("acc", "db_extra",
	"src_user=$fU;src_domain=$fd;src_ip=$si;"
	"dst_ouser=$tU;dst_user=$rU;dst_domain=$rd")
#!endif
 
 
# ----- usrloc params -----
/* enable DB persistency for location entries */
#!ifdef WITH_USRLOCDB
modparam("usrloc", "db_url", DBKAMAILIO)
modparam("usrloc", "db_mode", 2)
modparam("usrloc", "use_domain", MULTIDOMAIN)
modparam("usrloc", "nat_bflag", FLB_NATB)
modparam("usrloc", "expires_column", "expires")
modparam("usrloc", "timer_interval", 120)
#!endif
 
 
# ----- auth_db params -----
#!ifdef WITH_AUTH
modparam("auth_db", "db_url", DBSWITCH)
modparam("auth_db", "user_column", "username")
modparam("auth_db", "calculate_ha1", yes)
modparam("auth_db", "password_column", "secret")
modparam("auth_db", "load_credentials", "")
 

 
# ----- permissions params -----
#!ifdef WITH_IPAUTH
modparam("permissions", "db_url", DBKAMAILIO)
modparam("permissions", "db_mode", 1)
#!endif
 
#!endif
 
 
# ----- alias_db params -----
#!ifdef WITH_ALIASDB
modparam("alias_db", "db_url", DBKAMAILIO)
modparam("alias_db", "use_domain", MULTIDOMAIN)
#!endif
  
# ----- domain params -----
#!ifdef WITH_MULTIDOMAIN
modparam("domain", "db_url", DBKAMAILIO)
# register callback to match myself condition with domains list
modparam("domain", "register_myself", 1)
#!endif

#!ifdef WITH_NAT
# ----- rtpproxy params -----
modparam("rtpproxy", "rtpproxy_sock", "udp:127.0.0.1:5899")
modparam("rtpproxy", "nortpproxy_str", "")

# ----- nathelper params -----
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", FLB_NATSIPPING)
modparam("nathelper", "sipping_from", "sip:pinger@kamailio.org")

# params needed for NAT traversal in other modules
modparam("nathelper|registrar", "received_avp", "$avp(RECEIVED)")
modparam("usrloc", "nat_bflag", FLB_NATB)
#!endif
# path.so
modparam("path", "use_received", 1)
 
#!ifdef WITH_TLS
# ----- tls params -----
modparam("tls", "config", "tls.cfg")
#!endif
 
#!ifdef WITH_ANTIFLOOD
# ----- pike params -----
modparam("pike", "sampling_time_unit", 6000)
modparam("pike", "reqs_density_per_unit", 60000)
modparam("pike", "remove_latency", 4)
 
# ----- htable params -----
# ip ban htable with autoexpire after 5 minutes
modparam("htable", "db_url", HASHDB)
modparam("htable", "htable", "userban=>size=16;autoexpire=60;dbtable=htable;")
modparam("htable", "htable", "a=>size=16;autoexpire=600;dbtable=htable;")
modparam("htable", "htable", "ipban=>size=16;autoexpire=60;dbtable=htable;")
modparam("htable", "htable", " cps =>size=16;autoexpire=1;dbtable=htable;")
modparam("htable", "htable", " ccps =>size=16;autoexpire=1;dbtable=htable;")

modparam("htable", "key_name_column", "key_name")
modparam("htable", "key_type_column", "key_type")
modparam("htable", "value_type_column", "value_type")
modparam("htable", "key_value_column", "key_value")
modparam("htable", "expires_column", "expires")
modparam("htable", "fetch_rows", 10000)
modparam("htable", "timer_interval", 10)
modparam("htable", "db_expires", 1)
modparam("htable", "timer_procs", 4)

#!endif
 
#!ifdef WITH_XMLRPC
# ----- xmlrpc params -----
modparam("xmlrpc", "route", "XMLRPC");
modparam("xmlrpc", "url_match", "^/RPC")
#!endif
 
#!ifdef WITH_DEBUG
# ----- debugger params -----
modparam("debugger","cfgtrace", 1)
modparam("debugger", "log_level_name", "exec")
modparam("debugger", "log_level", 4)
#!endif

modparam("sqlops","sqlcon",DBCA)
modparam("sqlops","sqlcon",DBCDRCA)

####### Routing Logic ########
##Dipatcher
modparam("dispatcher", "list_file", "/etc/kamailio/dispatcher.list")
modparam("dispatcher", "dst_avp", "$avp(dsdst)")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "cnt_avp", "$avp(dscnt)")
modparam("dispatcher", "grp_avp", "$avp(dsgrp)")
 
#set next two parameters if you want to enable balance alg. no. 10
#modparam("dispatcher", "dstid_avp", "$avp(dsdstid)")
#modparam("dispatcher", "ds_hash_size", 8)
modparam("dispatcher", "ds_ping_interval", 20)
modparam("dispatcher", "ds_ping_method", "INFO")
modparam("dispatcher", "ds_probing_mode", 1)
#modparam("dispatcher", "ds_probing_threshhold", 1)
#configure codes or classes of SIP replies to list only allowed replies (i.e. when temporarily unavailable=480)
modparam("dispatcher", "ds_ping_reply_codes", "class=2;code=480;code=404")
 
#!ifdef WITH_HOMER
# check IP and port of your capture node
modparam("siptrace", "duplicate_uri", "sip:10.10.10.10:9060")
modparam("siptrace", "hep_mode_on", 1)
modparam("siptrace", "trace_on", 1)
modparam("siptrace", "trace_to_database", 0)
modparam("siptrace", "trace_flag", 22)
modparam("siptrace", "hep_version", 1);
#!endif


####Dialog
modparam("dialog", "dlg_flag", 4)
modparam("dialog", "detect_spirals", 1)
modparam("dialog", "dlg_match_mode", 1)
modparam("dialog", "profiles_with_value", "caller;calls;crypto")

modparam("cfgutils", "initial_probability", 15)

#!ifdef WITH_EXEC
modparam("exec", "time_to_kill", 20)
#!endif
# Main SIP request routing logic
# - processing of any incoming SIP request starts with this route
# - note: this is the same as route { ... }
request_route {
	xlog("L_ALERT"," -------------------------------- New Call --------------------------------------- $rm \n");
	if ( is_method("OPTIONS") ) {
		if($fU=='sipsak'){
			sl_send_reply("500", "Server Dead");
			exit;
		}
	}

	if ( is_method("INFO") ) {
        	sl_send_reply("200", "OK");
                exit;
	}

	#!ifdef WITH_HOMER
	#start duplicate the SIP message now
			sip_trace();
			setflag(22);
	#!endif		
	# per request initial checks
	
	route(REQINIT);
 
	# NAT detection
	route(NATDETECT);
 
	# handle requests within SIP dialogs
	route(WITHINDLG);
 
	### only initial requests (no To tag)
 
	# CANCEL processing
	if (is_method("CANCEL")){
		if (t_check_trans())
			t_relay();
		exit;
	}
 	t_check_trans();
 	# authentication
	route(AUTH);
 	# record routing for dialog forming requests (in case they are routed)
	# - remove preloaded route headers
	remove_hf("Route");
	remove_hf("X-VoipMonitor-Custom1");

	if (is_method("INVITE|SUBSCRIBE"))
                record_route_preset("OV500LBIP:5060;nat=yes");
 
	# account only INVITEs
	if (is_method("INVITE"))
	{
		setflag(FLT_ACC); # do accounting
	}
 	# handle registrations
	route(REGISTRAR);
 	if ($rU==$null)
	{
		# request with no Username in RURI
		sl_send_reply("484","Address Incomplete");
		exit;
	}
 
	#DID provider list
	route(DIDPROVIDER);
	# dispatch destinations to PSTN
	route(PSTN); 
	# user location service
	route(LOCATION); 
	route(RELAY);
}
route[DIDPROVIDER]{
	if (is_method("REGISTER")){
        return;
    }

	if(!is_method("INVITE")){
		return;
	}
	$var(count) = 0;
	#Check list of valid IPS from SIP trunk
	if(ds_is_from_list("5")){	
	sql_xquery("ca","SELECT carrier.carrier_id, carrier.carrier_status, '1' AS gateway_withmedia, carrier_ips.carrier_ip_id AS enddevice_id, carrier.carrier_cps AS enddevice_cps, carrier.carrier_cc AS enddevice_cc, carrier_ips.carrier_ip_id, carrier.carrier_cps, carrier.carrier_cc from carrier INNER JOIN carrier_ips on carrier_ips.carrier_id = carrier.carrier_id  INNER JOIN did on did.carrier_id = carrier.carrier_id and did.did_number like concat('%', TRIM(LEADING '0' FROM  TRIM(LEADING '+' FROM '$rU'))) where ipaddress = '$si'    LIMIT 1;", "ra");
		
	xlog("L_ALERT","SELECT carrier.carrier_id, carrier.carrier_status, '1' AS gateway_withmedia, carrier_ips.carrier_ip_id AS enddevice_id, carrier.carrier_cps AS enddevice_cps, carrier.carrier_cc AS enddevice_cc, carrier_ips.carrier_ip_id, carrier.carrier_cps, carrier.carrier_cc from carrier INNER JOIN carrier_ips on carrier_ips.carrier_id = carrier.carrier_id  INNER JOIN did on did.carrier_id = carrier.carrier_id and did.did_number like concat('%', TRIM(LEADING '0' FROM  TRIM(LEADING '+' FROM '$rU'))) where ipaddress = '$si'   LIMIT 1;\n");
		
		$var(carrier_id)=$xavp(ra[0]=>carrier_id);	
		$var(carrier_status)=$xavp(ra[0]=>carrier_status);	
		$var(WITHMEDIA)=$xavp(ra[0]=>gateway_withmedia);
		#$var(WITHMEDIA2)=$xavp(ra[0]=>gateway_withmedia);	
			
		if($xavp(ra[0]=>carrier_id) != $null && $xavp(ra[0]=>carrier_id) != '' ){	
			append_hf("X-INCOMINGCARRIER: $xavp(ra[0]=>carrier_id)\r\n");
			append_hf("X-INCOMINGCARRIERDST: $rU\r\n");
			

			# Fix the media flow
			#if($hdr($var(WITHMEDIA)) == '1'){
			#	setflag(FLT_NATS);
			#}else{
			#	resetflag(FLT_NATS);
			#}
			
			setflag(FLT_NATS);
			append_hf("X-WITHMEDIA: 1\r\n");			
			append_hf("X-DEVICEID: $var(DEVICEID)\r\n");		
			append_hf("X-DEVICECC: $xavp(ra[0]=>enddevice_cc)\r\n");
			append_hf("X-DEVICECPS: $xavp(ra[0]=>enddevice_cps)\r\n");			
			append_hf("X-ACCOUNTCC: $xavp(ra[0]=>enddevice_cc)\r\n");
			append_hf("X-ACCOUNTCPS: $xavp(ra[0]=>enddevice_cps)\r\n");	
			append_hf("X-DEVICEID: $xavp(ra[0]=>enddevice_id)\r\n");				
			append_hf("X-MEDIP: $si\r\n");
			remove_hf("P-Preferred-Identity");
			remove_hf("P-Asserted-Identity");			
			msg_apply_changes();
			ds_select_dst("2", "4");									
			route(RELAY);		
			exit;
		}	
	}
}
 
route[RELAY] {
 
	# enable additional event routes for forwarded requests
	# - serial forking, RTP relaying handling, a.s.o.
	if (is_method("INVITE|SUBSCRIBE|UPDATE|INFO")) {
		t_on_branch("MANAGE_BRANCH");
		t_on_reply("MANAGE_REPLY");
	}
	if (is_method("INVITE|UPDATE|INFO")) {
		t_on_failure("MANAGE_FAILURE");
	}
 
	if (!t_relay()) {
		sl_reply_error();
	}
	exit;
}
 
# Per SIP request initial checks
route[REQINIT] {
#!ifdef WITH_ANTIFLOOD
	# flood dection from same IP and traffic ban for a while
	# be sure you exclude checking trusted peers, such as pstn gateways
	# - local host excluded (e.g., loop to self)
	#!ifdef WITH_EXEC
			#Run-time IPTable
			if ($ua =~ "(VoipSwitch|Asterisk)") {
				xdbg("Callfrom UA $ua\n");
			} else if($ua =~ "(zxcvfdf11|friendly-scanner|pplsip|sipvicious|sipcli|VaxSIPUserAgent|voxalot|MizuPhone|Ozeki|tramb2017|voip|hello|Independant|Skipper)") {			
				# silent drop for scanners
				xlog("L_INFO","Blocking scanners and pushing IPs to iptables");
				exec_avp("iptables -I INPUT -s $si -j DROP");
				exec_avp("/sbin/service iptables save");
				sl_send_reply("403", "Forbidden");
				exit;
			}
	#!endif	
	
	if (is_method("REGISTER")){
		if (!mf_process_maxfwd_header("10")) {
			sl_send_reply("483","Too Many Hops");
			exit;
		}
		if(!sanity_check("1511", "7")) {
			xlog("L_ALERT","Malformed SIP message from $si:$sp\n");
			send_reply("403", "Forbidden");
			exit;
		}
		return 1;
	}
	if(is_method("INVITE") || is_method("SUBSCRIBE") || is_method("REGISTER")){
	# flood detection from same IP and traffic ban for a while
		# be sure you exclude checking trusted peers, such as pstn gateways
		# - local host excluded (e.g., loop to self)
	if(src_ip!=myself)	{
			if($sht(ipban=>$si)!=$null) {
				# $fu is already blocked
				xdbg("request from blocked User - $fU,  $rm from $fu (IP:$si:$sp)\n");
				if(is_method("INVITE")){
						xlog("L_ALERT"," ALERT: $fU user source IP Address $si:$sp is already blocked.\n");
				}
				send_reply("403", "Forbidden");
				exit;
			}
			if (!pike_check_req()) {
				xlog("L_ALERT","Blocking traffic from $si\n");
				xlog("L_ALERT","ALERT: pike blocking $fU, $rm from $fu  (IP:$si:$sp)\n");
				$sht(ipban=>$si) = 1;
				xlog("L_ALERT","ALERT: $fU user source IP Address $si:$sp is blocking by system.\n");
				xlog("L_INFO","ALERT: INSERT INTO `htable` (`key_name`, `key_value`, ip, htime,serverid) VALUES ('$si', '1','$si',now(),'1')\n");
				sql_xquery("ca","INSERT INTO `htable` (`key_name`, `key_value`, ip, htime,serverid) VALUES ('$si', '1','$si',now(),'1')", "ra");
				sql_xquery("ca","INSERT INTO `htabledump` (`key_name`, `key_value`, ip, htime,serverid) VALUES ('$si', '1','$si',now(),'1')", "ra");
				send_reply("403", "Forbidden");
				exit;
			}
		}
		if($ua =~ "friendly-scanner") {
				sl_send_reply("200", "OK");
				exit;
		}                
	}

	if(!is_method("OPTIONS") && !is_method("SUBSCRIBE") && !is_method("NOTIFY") && !is_method("INVITE")){
	# flood detection from same IP and traffic ban for a while
	# be sure you exclude checking trusted peers, such as pstn gateways
	# - local host excluded (e.g., loop to self)
		if(src_ip!=myself) {
			if($sht(userban=>$fU)!=$null) {
				# $fu is already blocked
				xdbg("request from blocked User - $fU,  $rm from $fu (IP:$si:$sp)\n");
				if(is_method("INVITE")){
					xlog("L_ALERT"," ALERT: $fU user source IP Address $si:$sp is already blocked.\n");
				}
				send_reply("403", "Forbidden");
				exit;
			}
			if (!pike_check_req()) {
				xlog("L_ALERT","ALERT: pike blocking $fU, $rm from $fu  (IP:$si:$sp)\n");
				xlog("L_ALERT","Blocking traffic from $si\n");
				$sht(userban=>$fU) = 1;

				 xlog("L_ALERT","ALERT: $fU user source IP Address $si:$sp is blocking by system.\n");
				xlog("L_INFO","ALERT: INSERT INTO `htable` (`key_name`, `key_value`, ip, htime,serverid) VALUES ('$fU', '1','$si',now(),'1')\n");
				sql_xquery("ca","INSERT INTO `htable` (`key_name`, `key_value`, ip, htime,serverid) VALUES ('$fU', '1','$si',now(),'1')", "ra");
				sql_xquery("ca","INSERT INTO `htabledump` (`key_name`, `key_value`, ip, htime,serverid) VALUES ('$fU', '1','$si',now(),'1')", "ra");
				send_reply("403", "Forbidden");
				exit;
			}
		}
		if($ua =~ "friendly-scanner") {
				sl_send_reply("200", "OK");
				exit;
		}
	}
#!endif
 
	if (!mf_process_maxfwd_header("10")) {
		sl_send_reply("483","Too Many Hops");
		exit;
	}
	if(is_method("OPTIONS") && uri==myself && $rU==$null) {
		sl_send_reply("200","Keepalive");
		exit;
	}

	if(!sanity_check("1511", "7")) {
		xlog("Malformed SIP message from $si:$sp\n");
		exit;
	}
}
 
# Handle requests within SIP dialogs
route[WITHINDLG] {	
	if (has_totag()) {
		# sequential request withing a dialog should
		# take the path determined by record-routing
		if (loose_route()) {
			if (is_method("BYE")) {
				setflag(FLT_ACC); # do accounting ...
				setflag(FLT_ACCFAILED); # ... even if the transaction fails
			}
			if ( is_method("ACK") ) {
				# ACK is forwarded statelessy
				route(NATMANAGE);
			}
			remove_hf("X-FROMURI");
			remove_hf("X-CARRIERCPS");
			remove_hf("X-CARRIERID");
			remove_hf("X-MEDIP");
			remove_hf("X-ACCOUNTCODE");
			remove_hf("X-DEVICEID");
			remove_hf("X-DEVICECC");
			remove_hf("X-DEVICECPS");
			remove_hf("X-ACCOUNTID");
			remove_hf("X-ACCOUNTCC");
			remove_hf("X-ACCOUNTCPS");
			remove_hf("X-WITHMEDIA");
			remove_hf("X-DEVICETYPE");
			remove_hf("X-SRC-ACCOUNT");
			remove_hf("X-SRC-MED-IP");
			remove_hf("X-FS-Support");
			remove_hf("X-DSTURI");
			remove_hf("X-GMEDIA");
			remove_hf("X-RE");
			remove_hf("X-Billing-Code");
			remove_hf("X-AI");
			remove_hf("X-PU");
			remove_hf("X-MEDIATRA");
			remove_hf("X-INCOMINGCARRIER");
			remove_hf("X-INCOMINGCARRIERDST");
			remove_hf("X-DEVICEID-1");
			remove_hf("Allow-Events");
			msg_apply_changes();
			route(RELAY);
		} else {
			if (is_method("SUBSCRIBE") && uri == myself) {
				# in-dialog subscribe requests
				sl_send_reply("404","Not here");
				exit;
			}
			if ( is_method("ACK") ) {
				if ( t_check_trans() ) {
					# no loose-route, but stateful ACK;
					# must be an ACK after a 487
					# or e.g. 404 from upstream server
					t_relay();
					exit;
				} else {
					# ACK without matching transaction ... ignore and discard
					exit;
				}
			}
			sl_send_reply("404","Not here");
		}
		exit;
	}
}
 
# Handle SIP registrations
route[REGISTRAR] {
	if (!is_method("REGISTER")){
		return;
	}
	if (is_method("REGISTER")){
		if(isflagset(FLT_NATS))	{
			setbflag(FLB_NATB);
		# uncomment next line to do SIP NAT pinging 
			 setbflag(FLB_NATSIPPING);
		}
		
	sql_xquery("ca","select ipaddress, ipauthfrom, FIND_IN_SET('$si',ipaddress) state,  FIND_IN_SET('$fd',ipaddress) state2,  account_id from customer_sip_account where  username ='$fU';", "ra");
	xlog("L_ALERT"," REGISTRAR: select ipaddress, ipauthfrom, FIND_IN_SET('$si',ipaddress) state,  FIND_IN_SET('$fd',ipaddress) state2,  account_id from customer_sip_account where  username ='$fU';\n");

	xlog("L_ALERT","Registrar User name $fU $xavp(ra[0]=>ipaddress) $xavp(ra[0]=>ipauthfrom)\n");	
	#IP Restriction check	
	$var(ACCOUNTCODE)=$xavp(ra[0]=>account_id);	
	xlog("L_ALERT","ACCOUNTID $var(ACCOUNTCODE)\n");
	if($xavp(ra[0]=>ipaddress) != $null && $xavp(ra[0]=>ipaddress) != '' && $xavp(ra[0]=>ipauthfrom) != 'NO'){
		if($xavp(ra[0]=>ipaddress) != $null && $xavp(ra[0]=>ipaddress) != '' and $xavp(ra[0]=>ipauthfrom) == "SRC" && $xavp(ra[0]=>state) == '0' ){
			if($xavp(ra[0]=>ipauthfrom) != $null){
				$var(host) = $(ct{tobody.host});
				xlog("L_ALERT","Registrar User name $fU $xavp(ra[0]=>ipaddress) $xavp(ra[0]=>ipauthfrom) $fd $var(host)\n");			
				sql_result_free("ra");
				send_reply("403", "Forbidden");
				exit;		
			}else if($xavp(ra[0]=>ipaddress) != $null && $xavp(ra[0]=>ipaddress) != '' and $xavp(ra[0]=>ipauthfrom) == "FROM" && $xavp(ra[0]=>state2) == '0' ){
				if($xavp(ra[0]=>ipauthfrom) != $null){
					$var(host) = $(ct{tobody.host});
					xlog("L_ALERT","Registrar User name $fU $xavp(ra[0]=>ipaddress) $xavp(ra[0]=>ipauthfrom) $fd $var(host)\n");			
					sql_result_free("ra");
					send_reply("403", "Forbidden");
					exit;		
				}else {
					if( $xavp(ra[0]=>ipaddress) == $src_ip){
						sql_result_free("ra");
						send_reply("403", "Forbidden");
						exit;
					}
				}
			}
		}
	}
	if (!save("location","0x04")){
		sl_reply_error();
	}
 	exit;
	}
}



# Routing to FS
route[CALLS] {
	if(!is_method("INVITE")){
		return;
	}	
	if(is_method("INVITE")){
		#!ifdef WITH_FREESWITCH
			if(route(FROMFREESWITCH))
				return 1;
		#!endif
	}
	# Billing Code	

	if($hdr(X-Billing-Code) == $null){
		xlog("L_ALERT","-----------------------  Billing Code Header Not Set ----------------\n");
		sql_xquery("ca","SELECT account.status_id account_status, customer_sip_account.`status` device_status, media_transcoding, ipaddress, customer_sip_account.account_id, FIND_IN_SET('$si',ipaddress) state,  FIND_IN_SET('$fd',ipaddress) state2, ipauthfrom, account.id user_id, account.account_cc, account.account_cps, customer_sip_account.id enddevice_id, customer_sip_account.sip_cc enddevice_cc, customer_sip_account.sip_cps enddevice_cps, account.media_rtpproxy user_withmedia,'u' dtype from customer_sip_account INNER JOIN  account on customer_sip_account.account_id = account.account_id  INNER JOIN customer_voipminuts  on customer_voipminuts.account_id = account.account_id  where  username ='$fU' and account.account_type = 'CUSTOMER';", "ra");
		
		xlog("L_ALERT","IPAUTH User Check: SELECT account.status_id account_status, customer_sip_account.`status` device_status, media_transcoding, ipaddress, customer_sip_account.account_id, FIND_IN_SET('$si',ipaddress) state,  FIND_IN_SET('$fd',ipaddress) state2, ipauthfrom, account.id user_id, account.account_cc, account.account_cps, customer_sip_account.id enddevice_id, customer_sip_account.sip_cc enddevice_cc, customer_sip_account.sip_cps enddevice_cps, account.media_rtpproxy user_withmedia,'u' dtype from customer_sip_account INNER JOIN  account on customer_sip_account.account_id = account.account_id  INNER JOIN customer_voipminuts  on customer_voipminuts.account_id = account.account_id  where  username ='$fU' and account.account_type = 'CUSTOMER';\n");
		
		xlog("L_ALERT","Call from User name $fU $xavp(ra[0]=>ipaddress) $xavp(ra[0]=>ipauthfrom)\n");
		
		if($xavp(ra[0]=>account_id) == $null && $xavp(ra[0]=>account_id) == '' ){
		
			xlog("L_ALERT","INVITE IP AUTH Check :  SELECT customer_ips.billingcode, account.status_id account_status, ipauthfrom, customer_ips.ip_status device_status, media_transcoding, ipaddress, customer_ips.account_id, FIND_IN_SET('$si',ipaddress) state,  FIND_IN_SET('$fd',ipaddress) state2, customer_ips.id enddevice_id, customer_ips.ip_cps enddevice_cps, customer_ips.ip_cc enddevice_cc, account.id user_id, account.account_cc, account.account_cps, account.media_rtpproxy user_withmedia,'ip' dtype from customer_ips  INNER JOIN account on account.account_id = customer_ips.account_id  INNER JOIN customer_voipminuts  on customer_voipminuts.account_id = account.account_id  where  (customer_ips.billingcode is null or  customer_ips.billingcode = '' ) and  ipaddress = '$si' and '$rU' like dialprefix and account.account_type = 'CUSTOMER' ORDER BY dialprefix DESC limit 1; \n");	
			
			sql_result_free("ra");		
			#find the Account code	
			
			sql_xquery("ca"," SELECT customer_ips.billingcode, account.status_id account_status, ipauthfrom, customer_ips.ip_status device_status, media_transcoding, ipaddress, customer_ips.account_id, FIND_IN_SET('$si',ipaddress) state,  FIND_IN_SET('$fd',ipaddress) state2, customer_ips.id enddevice_id, customer_ips.ip_cps enddevice_cps, customer_ips.ip_cc enddevice_cc, account.id user_id, account.account_cc, account.account_cps, account.media_rtpproxy user_withmedia,'ip' dtype from customer_ips  INNER JOIN account on account.account_id = customer_ips.account_id  INNER JOIN customer_voipminuts  on customer_voipminuts.account_id = account.account_id  where  (customer_ips.billingcode is null or  customer_ips.billingcode = '' ) and  ipaddress = '$si' and '$rU' like dialprefix and account.account_type = 'CUSTOMER' ORDER BY dialprefix DESC limit 1;", "ra");
		}

		if($xavp(ra[0]=>account_status) != '1' || $xavp(ra[0]=>device_status) != '1' ){		
			sql_result_free("ra");
			send_reply("401", "Account Suspended");
			exit;
		}


	}else{

		xlog("L_ALERT","-----------------------  Billing Code Header is  Set and it is $hdr(X-Billing-Code) ----------------\n");

		xlog("L_ALERT","INVITE IP AUTH Check :  SELECT account.status_id account_status, ipauthfrom, customer_ips.ip_status device_status, media_transcoding, ipaddress, customer_ips.account_id, FIND_IN_SET('$si',ipaddress) state,  FIND_IN_SET('$fd',ipaddress) state2, customer_ips.id enddevice_id, customer_ips.ip_cps enddevice_cps, customer_ips.ip_cc enddevice_cc, account.id user_id, account.account_cc, account.account_cps, account.media_rtpproxy user_withmedia,'ip' dtype from customer_ips  INNER JOIN account on account.account_id = customer_ips.account_id INNER JOIN customer_voipminuts  on customer_voipminuts.account_id = account.account_id  where customer_voipminuts.billingcode = '$hdr(X-Billing-Code)' and ipaddress = '$si' and '$rU' like dialprefix and account.account_type = 'CUSTOMER' ORDER BY dialprefix DESC limit 1; \n");
		
		sql_xquery("ca","SELECT account.status_id account_status, ipauthfrom, customer_ips.ip_status device_status, media_transcoding, ipaddress, customer_ips.account_id, FIND_IN_SET('$si',ipaddress) state,  FIND_IN_SET('$fd',ipaddress) state2, customer_ips.id enddevice_id, customer_ips.ip_cps enddevice_cps, customer_ips.ip_cc enddevice_cc, account.id user_id, account.account_cc, account.account_cps, account.media_rtpproxy user_withmedia,'ip' dtype from customer_ips  INNER JOIN account on account.account_id = customer_ips.account_id INNER JOIN customer_voipminuts  on customer_voipminuts.account_id = account.account_id  where customer_voipminuts.billingcode = '$hdr(X-Billing-Code)' and ipaddress = '$si' and '$rU' like dialprefix and account.account_type = 'CUSTOMER' ORDER BY dialprefix DESC limit 1;", "ra");

		if($xavp(ra[0]=>account_status) != '1' || $xavp(ra[0]=>device_status) != '1' ){		
			sql_result_free("ra");
			send_reply("401", "Account Suspended");
			exit;
		}
	}
	
	xlog("L_ALERT","Call from User name account  $fU $xavp(ra[0]=>account_id) $xavp(ra[0]=>enddevice_id)\n");	
	$var(count) = 0;	
	#IP Restriction check	
	#$var(ACCOUNTCODE)=$xavp(ra[0]=>account_id);	
	##IP Restriction check
	$var(ACCOUNTCODE)=$xavp(ra[0]=>account_id);		
	$var(DEVICEID)=$xavp(ra[0]=>enddevice_id);
	$var(DEVICECC)=$xavp(ra[0]=>enddevice_cc);
	$var(DEVICECPS)=$xavp(ra[0]=>enddevice_cps);	
	$var(DEVICETYPE)=$xavp(ra[0]=>dtype);	
	$var(ACCOUNTID)=$xavp(ra[0]=>user_id);
	$var(ACCOUNTCC)=$xavp(ra[0]=>account_cc);
	$var(ACCOUNTCPS)=$xavp(ra[0]=>account_cps);
	$var(WITHMEDIA)=0;
	if($xavp(ra[0]=>media_transcoding) == "1" ||  $xavp(ra[0]=>user_withmedia) == '1'){	
		append_hf("X-WITHMEDIA: $var(WITHMEDIA)\r\n");
		#Set Media Proxy
		setflag(FLT_NATS);
	}else{
		resetflag(FLT_NATS);
	}
	xlog("L_ALERT","AA2  -- ACCOUNTCODE $var(ACCOUNTCODE)  DEVICEID $var(DEVICEID)  DEVICECC $var(DEVICECC) DEVICECPS $var(DEVICECPS) ACCOUNTID $var(ACCOUNTID)  ACCOUNTCC $var(ACCOUNTCC) ACCOUNTCPS $var(ACCOUNTCPS)  WITHMEDIA $var(WITHMEDIA) \n");  
	if(sdp_get_line_startswith("$avp(mline)", "c=")) {
		xlog("L_ALERT","m-line: $avp(mline) $(avp(mline){s.substr,8,$(avp(mline){s.len})})\n");
		#append_hf("X-MEDIP: $(avp(mline){s.substr,8,$(avp(mline){s.len})})\r\n");
		append_hf("X-MEDIP: $si\r\n");
		append_hf("X-ACCOUNTCODE: $var(ACCOUNTCODE)\r\n");
		append_hf("X-DEVICEID: $var(DEVICEID)\r\n");
		append_hf("X-DEVICECC: $var(DEVICECC)\r\n");
		append_hf("X-DEVICECPS: $var(DEVICECPS)\r\n");
		append_hf("X-ACCOUNTID: $var(ACCOUNTID)\r\n");
		append_hf("X-ACCOUNTCC: $var(ACCOUNTCC)\r\n");
		append_hf("X-ACCOUNTCPS: $var(ACCOUNTCPS)\r\n");		
		append_hf("X-DEVICETYPE: $var(DEVICETYPE)\r\n");
		append_hf("X-RE: $re\r\n");
		append_hf("X-AI: $ai\r\n");
		append_hf("X-PU: $pU\r\n");		
		remove_hf("Diversion");
		msg_apply_changes();
		xlog("L_ALERT","msg_apply_changes CALLS Route\n");
	}

	if($(var(ACCOUNTCODE){s.len}) > 1 ){
		route(CPSCHECK);
	}
			
	xlog("L_ALERT","AA3  -- ACCOUNTCODE $var(ACCOUNTCODE)  DEVICEID $var(DEVICEID)  DEVICECC $var(DEVICECC) DEVICECPS $var(DEVICECPS) ACCOUNTID $var(ACCOUNTID)  ACCOUNTCC $var(ACCOUNTCC) ACCOUNTCPS $var(ACCOUNTCPS)  WITHMEDIA $var(WITHMEDIA) \n");  
	if ($xavp(ra[0]=>account_id) != $null && $xavp(ra[0]=>account_id) != '' && $xavp(ra[0]=>ipaddress) != $null && $xavp(ra[0]=>ipaddress) != '' && $xavp(ra[0]=>ipauthfrom) != "NO"){
	
		if($xavp(ra[0]=>ipaddress) != $null && $xavp(ra[0]=>ipaddress) != '' ){
			if($xavp(ra[0]=>ipauthfrom) != $null){
				$var(host) = $(ct{tobody.host});
				xlog("L_ALERT","Registrar User name $fU  $xavp(ra[0]=>ipaddress) $xavp(ra[0]=>ipauthfrom) $fd $var(host)\n");
				if(($xavp(ra[0]=>ipauthfrom) == "SRC" && $xavp(ra[0]=>state) == '0')  ){
					sql_result_free("ra");
					send_reply("403", "Forbidden");
					exit;
				}
				if(($xavp(ra[0]=>ipauthfrom) == "FROM" && $xavp(ra[0]=>state2) == '0')  ){
					sql_result_free("ra");
					send_reply("403", "Forbidden");
					exit;
				}
			}else {
				if( $xavp(ra[0]=>ipaddress) == $src_ip){
					sql_result_free("ra");
					send_reply("403", "Forbidden");
					exit;
				}
			}
		}
		
		if ($xavp(ra[0]=>dtype) == 'u'){		
			if (!proxy_authorize("$fd", "customer_sip_account")) {
				proxy_challenge("$fd", "1"); 				
				exit;			
			};
		};
		ds_select_dst("2", "4");		
		msg_apply_changes();
		xlog("L_ALERT","!!!!!!!!dst list $du $ru $avp(dscnt)  dst_avp($avp(dsdst)) dst_avp($(avp(dsdst)[0]))  $avp(dsdst) $(avp(dsdst)[0]) $(avp(dsdst)[1]) $(avp(dsdst)[2])\n");
		if($(var(ACCOUNTCODE){s.len}) > 1 ){
			route(CPSSET);
		}
		route(RELAY);		
		exit;
	}else if ($xavp(ra[0]=>account_id) != $null && $xavp(ra[0]=>account_id) != '' && $xavp(ra[0]=>ipauthfrom) == "NO"){					
		if (!proxy_authorize("$fd", "customer_sip_account")) {
			proxy_challenge("$fd", "1"); 				
			exit;			
		};

		ds_select_dst("2", "4");		
		msg_apply_changes();
		xlog("L_ALERT","!!!!!!!!dst list $du $ru $avp(dscnt)  dst_avp($avp(dsdst)) dst_avp($(avp(dsdst)[0]))  $avp(dsdst) $(avp(dsdst)[0]) $(avp(dsdst)[1]) $(avp(dsdst)[2])\n");
		if($(var(ACCOUNTCODE){s.len}) > 1 ){
			route(CPSSET);
		}
		route(RELAY);		
		exit;
	}	
}

# CUSTOMER location service
route[LOCATION] {
	if(is_method("INVITE") && (!route(FROMFREESWITCH))) {	
		route(CALLS);
		exit;
	}
	remove_hf("Allow-Events");
	remove_hf("X-FS-Support");
	remove_hf("X-FROMURI");
	remove_hf("X-CARRIERCPS");
	remove_hf("X-CARRIERID");
	remove_hf("X-MEDIP");
	remove_hf("X-ACCOUNTCODE");
	remove_hf("X-DEVICEID");
	remove_hf("X-DEVICECC");
	remove_hf("X-DEVICECPS");
	remove_hf("X-ACCOUNTID");
	remove_hf("X-ACCOUNTCC");
	remove_hf("X-ACCOUNTCPS");
	remove_hf("X-WITHMEDIA");
	remove_hf("X-DEVICETYPE");
	remove_hf("X-SRC-ACCOUNT");
	remove_hf("X-SRC-MED-IP");
	remove_hf("X-FS-Support");
	remove_hf("X-DSTURI");
	remove_hf("X-GMEDIA");
	remove_hf("X-RE");
	remove_hf("X-AI");
	remove_hf("X-PU");
	remove_hf("X-MEDIATRA");
	remove_hf("X-INCOMINGCARRIER");
	remove_hf("X-INCOMINGCARRIERDST");
	remove_hf("X-DEVICEID-1");
	remove_hf("Allow-Events");
        remove_hf("X-Billing-Code");
	remove_hf("User-Agent");
	append_hf("User-Agent: OV500-2.0.0\r\n");
	msg_apply_changes();

	$avp(oexten) = $rU;
	if (!lookup("location")) {
		$var(rc) = $rc;		
		t_newtran();
		switch ($var(rc)) {
			case -1:
			case -3:
				send_reply("404", "Not Found");
				exit;
			case -2:
				send_reply("405", "Method Not Allowed");
				exit;
		}
	}
 
	# when routing via usrloc, log the missed calls also
	if (is_method("INVITE"))
	{
		setflag(FLT_ACCMISSED);
	}
	
}
 
 
# Authentication route
route[AUTH] {
	if(ds_is_from_list("5")){	
		return 1;
	}
#!ifdef WITH_AUTH
	#!ifdef WITH_FREESWITCH
	if(route(FROMFREESWITCH))		
		return 1;
	#!endif

	sql_query("ca","select ipaddress, ipauthfrom, FIND_IN_SET('$si',ipaddress) state, account_id  from customer_ips where ipaddress = '$si' ;", "ra");
	if($dbr(ra=>rows)>0) {		
		if ($xavp(ra=>state) =='1'  && $xavp(ra=>ipauthfrom) == 'SRC'){
			xlog("L_ALERT", "IP Auth available allowed.\n");
			return;
		}
	}
	if (is_method("REGISTER") || from_uri==myself) {		   
		xlog("L_ALERT","REGISTER - d[$mi] m[$rm] r[0] [$fu -> $ru ($tu)]: User $fu src_ip $si\n");
		sql_query("ca","select ipaddress, ipauthfrom, FIND_IN_SET('$si',ipaddress) state,  FIND_IN_SET('$fd',ipaddress) state2,  account_id from customer_sip_account where  username ='$fU';", "ra");
		xlog("L_ALERT","select ipaddress, ipauthfrom, FIND_IN_SET('$si',ipaddress) state,  FIND_IN_SET('$fd',ipaddress) state2,  account_id from customer_sip_account where  username ='$fU';\n");
		if($dbr(ra=>rows)>0) {
			xlog("L_ALERT","Checking IP restrictions for $si IP of $fU user for REGISTER request.\n");
			if ($xavp(ra=>state) =='0'  && $xavp(ra=>ipauthfrom) == 'SRC'){
				xlog("L_ALERT", "User $fU source IP $si not allowed.\n");
				sl_send_reply("403","Fobidden Auth ID");
				exit;
			}else if ($xavp(ra=>state2) =='0'  && $xavp(ra=>ipauthfrom) == 'FROM'){
				xlog("L_ALERT", "User $fU source IP $si not allowed.\n");
				sl_send_reply("403","Fobidden Auth ID");
				exit;
			} else {
				xlog("L_ALERT", "Trying to Authorize SIP User $fU (digest Auth) \n");
				$var(ACCOUNTCODE) = $xavp(ra=>account_id);
				route(AUTH2);
			}
		} else {
			xlog("L_ALERT", "User $fU IP auth is not active SWITCH \n");
			$var(ACCOUNTCODE) = $xavp(ra=>account_id);
			route(AUTH2);
		}
		sql_result_free("ra");
		# user authenticated - remove auth header
		if(!is_method("REGISTER|PUBLISH"))
			consume_credentials();		
	}	
	# if caller is not local subscriber, then check if it calls
	# a local destination, otherwise deny, not an open relay here
	if (from_uri!=myself && uri!=myself)	{
		sl_send_reply("403","Not relaying");
		exit;
	}
 #!endif
}
 
route[AUTH2] {
	if (is_method("REGISTER") || from_uri==myself){
			if($sht(a=>$au::auth_count)==5){
				$var(exp) = $Ts - 900;
				if($sht(a=>$au::last_auth) > $var(exp)) {
					sl_send_reply("403", "Try later");
					exit;
				} else {
					$sht(a=>$au::auth_count) = 0;
				}
			}
			# authenticate requests

			if (!auth_check("$fd", "customer_sip_account", "1")) {
				switch ($retcode) {
					case -1:
						sl_send_reply("403", "Forbidden");
						exit;
					case -2:
						if($sht(a=>$au::auth_count) == $null)
							$sht(a=>$au::auth_count) = 0;
						$sht(a=>$au::auth_count) = $sht(a=>$au::auth_count) + 1;
						if($sht(a=>$au::auth_count) == 5)
							xlog("L_ALERT","Auth failed 5th time - src ip: $si\n");
						$sht(a=>$au::last_auth) = $Ts;
						break;
				}
				auth_challenge("$fd", "0");
				exit;
			}
			$sht(a=>$au::auth_count) = 0;
			# user authenticated - remove auth header
			if(!is_method("REGISTER|PUBLISH")){
				consume_credentials();
			}
		}
		if (from_uri!=myself && uri!=myself) {
			sl_send_reply("403","Fobidden Auth ID");
			exit;
		}
	return;
}
 
# Caller NAT detection route
route[NATDETECT] {
#!ifdef WITH_NAT
	force_rport();
	if (nat_uac_test("19")) {
		if (is_method("REGISTER")) {
			fix_nated_register();
		} else {
			fix_nated_contact();
		}
		setflag(FLT_NATS);
	}
#!endif
	return;
}
 
# RTPProxy control
route[NATMANAGE] {
#!ifdef WITH_NAT
	if (is_request()) {
		if(has_totag()) {
			if(check_route_param("nat=yes")) {
				setbflag(FLB_NATB);
			}
		}
	}	
	if(get_profile_size("calls","$ci","$avp(size)")){
		xlog("L_ALERT","currently there are $avp(size) Media Enabled\n");
		if($avp(size) > 0){
			setbflag(FLB_NATB);
		}
	}	
	if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB)))
		return;
	rtpproxy_manage();
	set_dlg_profile("calls","$ci");	
	if (is_request()) {
		if (!has_totag()) {
			add_rr_param(";nat=yes");
		}
	}
	if (is_reply()) {
		if(isbflagset(FLB_NATB)) {
			fix_nated_contact();
		}
	}
#!endif
	return;
}
 
route[CCPSCHECK]{
		
	if($sht(ccps=>$var(CARRIERID)::cps_count) == $null){
		$sht(ccps=>$var(CARRIERID)::cps_count) = 0;
	}
	
	if($Ts > $sht(ccps=>$var(CARRIERID)::last_cps_count)){
		$sht(ccps=>$var(CARRIERID)::cps_count) = 0;
	}
	xlog("L_ALERT","----CPSLOG---------- $var(CARRIERID) : $var(CARRIERCPS) COUNT $sht(ccps=>$var(CARRIERID)::cps_count)  TIME  $Ts \n");
	if ($var(CARRIERCPS) == 0){		
		return 1;		
	}
	
	$var(CARRIERCPS3) = $var(CARRIERCPS)*1;
	if($sht(ccps=>$var(CARRIERID)::cps_count)>$var(CARRIERCPS3)){
		$var(exp) = $Ts - 1;
		if($sht(ccps=>$var(CARRIERID)::last_cps_count) > $var(exp)){                                                              
			return 1;			
		} else {
			$sht(ccps=>$var(CARRIERID)::cps_count) = 0;
		}
	}
	return -1;
}

route[CCPSSET]{
	if($sht(ccps=>$var(CARRIERID)::cps_count) == $null){
		$sht(ccps=>$var(CARRIERID)::cps_count) = 0;
	}
	$sht(ccps=>$var(CARRIERID)::cps_count) = $sht(ccps=>$var(CARRIERID)::cps_count) + 1;	
	$sht(ccps=>$var(CARRIERID)::last_cps_count) = $Ts;
}


route[CPSCHECK]{
	if($sht(cps=>$var(ACCOUNTCODE)::cps_count) == $null){
	                $sht(cps=>$var(ACCOUNTCODE)::cps_count) = 0;
	}
	if($Ts > $sht(cps=>$var(ACCOUNTCODE)::last_cps_count)){
		$sht(cps=>$var(ACCOUNTCODE)::cps_count) = 0;
	}
	xlog("L_ALERT","----CPSLOG---------- $var(ACCOUNTCODE) : $var(ACCOUNTCPS) COUNT $sht(cps=>$var(ACCOUNTCODE)::cps_count)  TIME  $Ts \n");
	if ($var(ACCOUNTCPS) == 0){
		sql_xquery("cdrca","insert into switch_cdrs (user_account_id,fscause,Q850CODE,SIPCODE,start_stamp,end_stamp, user_src_ip,hangupby, sip_from_user, sip_to_user , user_src_caller , user_src_callee,fs_errorcode) values('$var(ACCOUNTCODE)','LB_DISCONNECTED','0','503',now(),now(), '$si','system', '$fU','$tU', '$fU','$tU','CUSTOMERCPSISSUE');", "ra");     
		
		xlog("L_ALERT","CPS - insert into switch_cdrs (user_account_id,fscause,Q850CODE,SIPCODE,start_stamp,end_stamp, user_src_ip,hangupby, sip_from_user, sip_to_user , user_src_caller , user_src_callee,fs_errorcode) values('$var(ACCOUNTCODE)','LB_DISCONNECTED','0','503',now(),now(), '$si','system', '$fU','$tU','$fU','$tU','CUSTOMERCPSISSUE');\n");
		sl_send_reply("503", "Try later CPS limit issue");
		exit;
	}
	$var(ACCOUNTCPS3) = $var(ACCOUNTCPS)*1;
	if($sht(cps=>$var(ACCOUNTCODE)::cps_count)>$var(ACCOUNTCPS3)){
		$var(exp) = $Ts - 1;
		if($sht(cps=>$var(ACCOUNTCODE)::last_cps_count) > $var(exp)){                                                              
			sql_xquery("cdrca","insert into switch_cdrs (user_account_id,fscause,Q850CODE,SIPCODE,start_stamp,end_stamp, user_src_ip,hangupby, sip_from_user, sip_to_user , user_src_caller , user_src_callee,fs_errorcode) values('$var(ACCOUNTCODE)','LB_DISCONNECTED','0','503',now(),now(), '$si','system', '$fU','$tU', '$fU','$tU','CUSTOMERCPSISSUE');", "ra");                       
			xlog("L_ALERT","CPS - insert into switch_cdrs (user_account_id,fscause,Q850CODE,SIPCODE,start_stamp,end_stamp, user_src_ip,hangupby, sip_from_user, sip_to_user , user_src_caller , user_src_callee,fs_errorcode) values('$var(ACCOUNTCODE)','LB_DISCONNECTED','0','503',now(),now(), '$si','system', '$fU','$tU', '$fU','$tU','CUSTOMERCPSISSUE');\n");
			sl_send_reply("503", "Try later CPS limit issue");
			exit;
		} else {
			$sht(cps=>$var(ACCOUNTCODE)::cps_count) = 0;
		}
	}
}

route[CPSSET]{
	if($sht(cps=>$var(ACCOUNTCODE)::cps_count) == $null){
		$sht(cps=>$var(ACCOUNTCODE)::cps_count) = 0;
	}
	$sht(cps=>$var(ACCOUNTCODE)::cps_count) = $sht(cps=>$var(ACCOUNTCODE)::cps_count) + 1;
	$sht(cps=>$var(ACCOUNTCODE)::last_cps_count) = $Ts;
}
# PSTN GW routing
route[PSTN] {	
	
		if($hdr(X-DSTURI) == $null){
			return;
		}else { 
		
		#!ifdef WITH_FREESWITCH
			if(route(FROMFREESWITCH)){
				#External Call  sip_h_X-CARRIERCPS    sip_h_X-CARRIERID			
				$var(CARRIERCPS) = $hdr(X-CARRIERCPS);
				$var(CARRIERID) = $hdr(X-CARRIERID);
				xlog("L_ALERT","Carrier Allowed CPS $var(CARRIERCPS) for carrier $hdr(X-CARRIERID)\n");
				if(route(CCPSCHECK)){
					  sl_send_reply("515", "Limit issue");
					  exit;
				}	
				$avp(oexten) = $rU;
				$ru = $hdr(X-DSTURI);
				#$du = $null;
				$tu = $ru;	
				$var(MEDIATRA) = $hdr(X-MEDIATRA);
				if($hdr(X-MEDIATRA) == '1'){
					setflag(FLT_NATS);
				}else{
					resetflag(FLT_NATS);
				}
				remove_hf("X-FROMURI");
				remove_hf("X-CARRIERCPS");
				remove_hf("X-CARRIERID");	
				remove_hf("X-MEDIP");
				remove_hf("X-ACCOUNTCODE");
				remove_hf("X-DEVICEID");
				remove_hf("X-DEVICECC");
				remove_hf("X-DEVICECPS");
				remove_hf("X-ACCOUNTID");
				remove_hf("X-ACCOUNTCC");
				remove_hf("X-ACCOUNTCPS");
				remove_hf("X-WITHMEDIA");
				remove_hf("X-DEVICETYPE");
				remove_hf("X-SRC-ACCOUNT");
				remove_hf("X-SRC-MED-IP");
				remove_hf("X-FS-Support");
				remove_hf("X-DSTURI");	
				remove_hf("X-GMEDIA");		
				remove_hf("X-RE");
				remove_hf("X-AI");
				remove_hf("X-PU");		
				remove_hf("X-MEDIATRA");		
				remove_hf("Allow-Events");
				remove_hf("User-Agent");
				remove_hf("X-INCOMINGCARRIER");
				remove_hf("X-INCOMINGCARRIERDST");
				remove_hf("X-Billing-Code");
				remove_hf("X-DEVICEID-1");
				append_hf("User-Agent: OV500-2.0.0\r\n");
				msg_apply_changes();
				# when routing via usrloc, log the missed calls also
				if (is_method("INVITE")) {
					setflag(FLT_ACCMISSED);
				}	
				if($(var(CARRIERID){s.len}) > 1 ){
					route(CCPSSET);
				}
				route(RELAY);
				exit;
			}
		}
		#!endif
}

# manage outgoing branches
branch_route[MANAGE_BRANCH] {
	xdbg("new branch [$T_branch_idx] to $ru\n");
	route(NATMANAGE);
}
 
# manage incoming replies
onreply_route[MANAGE_REPLY] {
	xdbg("incoming reply\n");
	if(status=~"[12][0-9][0-9]")
		route(NATMANAGE);
}
 
# manage failure routing cases
failure_route[MANAGE_FAILURE] {
	route(NATMANAGE); 
	if (t_is_canceled()) {
		exit;
	}
 
#!ifdef WITH_BLOCK3XX
	# block call redirect based on 3xx replies.
	if (t_check_status("3[0-9][0-9]")) {
		t_reply("404","Not found");
		exit;
	}
#!endif
 
#!ifdef WITH_CODE486408
	# serial forking	
	if (t_check_status("408")) {	
		t_reply("486","Busy");
		exit;		
	}	
	if (t_check_status("408")) {
		#------------ Anand Need to add the failover route
		t_reply("486","Request Timeout");
		exit;
		
	}	
#!endif
}
 
#!ifdef WITH_FREESWITCH
# Test if coming from Asterisk
route[FROMFREESWITCH] {
	if(ds_is_from_list("2")){		
		return 1;
	}
	return -1;
} 
#!endif
